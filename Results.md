## Methods: 

- We used repl an online compilation tool which offers support for multiple languages including the three languages we have chosen for our project - Lua, Go and Ruby. 
- We monitored the debugging session with each participant to understand their thought process and to resolve any issues they were facing. 
- We kept track of the time they took for each language. 
- We also created a survey which questioned the subjects on the languages they were already familiar with to ensure that the results are not tampered with subjects who were already familiar with the language. 
- We also questioned them on the difficulty of the bugs to get feedback on the quality of bugs we introduced. 

## Materials: 

1. Repl 
2. Survey 
3. Monitored zoom session 

## Observations:

###### Familiarity of Languages among the participants:
![image](https://user-images.githubusercontent.com/30931862/92041356-12f8a480-ed46-11ea-9fe8-89bb654f2618.png)


###### Ranking of languages based on difficulty in Debugging:
![image](https://user-images.githubusercontent.com/30931862/92041486-57844000-ed46-11ea-9ddb-1e151d59b88b.png)


###### Difficulty of Bugs based on participants review
![image](https://user-images.githubusercontent.com/30931862/92041539-6965e300-ed46-11ea-99b0-dd77b971e087.png)


- Language Complexity - The participants ranked Lua and Go to be most difficult to debug followed by Ruby.
- Most candidates used online resources to check for the correctness of the syntax
- Familiarity of the problem - The participants had a good familiarity with the GoL Problem with 70% participants having complete knowledge of the Problem
- Common Problems faced by the Participants in debugging - The participants did not know the proper syntax for each language
- Familiarity with the Language - Most participants did not have a familiarity with the languages however 20-30% of participants had knowledge of 1-2 languages that they were being tested on.
- The participants found bugs to be of intermediate level difficulty.

## Conclusion:
- The participants ranked Lua and Go to be most difficult to debug followed by Ruby.
- The participants took the longest time to debug Lua followed by Ruby and Go respectively.
- The participants found Go easy to understand and preferred it over the other languages.


## Threats to validity: 

- **Repeated Testing**: All the subjects were aware of the Game of Life problem and they had to implement the same problem too. Naturally, some of the implementation logic would have been similar and because of which the results may not have been accurate. Two of the subjects were already familiar with 2 out of 3 languages that we have chosen. One subject confirmed that he did his HW3 in Lua as well. This aspect of repeated testing may have affected the results of the trial as well.
- **Common algorithm in all implementations**: We wanted to maintain the same approach in all languages to ensure that the bug difficulty remains the same in all languages and does not impact the results but however, we realized that because of which, the subjects found a pattern in the bugs or rather they understood the pseudocode and starting figuring out the bugs faster. We noticed that with 2 of our subjects where they took the longest time for the first language they picked and decreased subsequently. 
- **Number of bugs incorporated in each language**: We included 4+ bugs in each language and after the trial we felt that some of the subjects did not get enough time to debug all three languages. We believe that if we reduced the number of bugs we introduced to about 2-3 then the trial would have been more effective. 
- **Public repository and easy availability of every groups code**: We believe that since all the repositories links are freely available to all the other students, it could have been a possibility that some of the subjects have referred to the implementations before their trial giving them an unfair advantage over the other subjects. This would have impacted the results of our trial unknowingly.
